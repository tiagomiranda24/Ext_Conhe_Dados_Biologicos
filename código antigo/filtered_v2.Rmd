---
title: "Projeto"
author: "Christian Neitzel, Diana Silva, Tiago Miranda"
date: "r format(Sys.time(), '%Y-%m-%d')"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Objetivo do trabalho:

Este trabalho contém uma análise demonstrativa de expressão genética diferencial, utilizando amostras de sequenciamento direcionado de 526 tumores de bexiga e seus normais correspondentes através do MSK-IMPACT. O conjunto de dados selecionado inclui 526 amostras de mais de 400 pacientes, nas quais a expressão genética foi quantificada.

Conjunto de Dados selecionados:
https://portal.gdc.cancer.gov/projects/TCGA-ACC 
https://www.ncbi.nlm.nih.gov/projects/gap/cgi-bin/study.cgi?study_id=phs000178.v11.p8&phv=354519&phd=&pha=&pht=7516&phvf=&phdf=&phaf=&phtf=&dssp=1&consent=&temp=1

Em primeiro lugar, procedemos à instalação dos packages necessários para realizar a análise da expressão diferencial.


```{r}
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
  BiocManager::install("cBioPortalData")

BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"))

# Instalação dos pacotes "GGally" e "tibble"
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
#install.packages("tibble")

# Carrega os pacotes instalados
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(DESeq2)

# Carregamento do pacote cBioPortalData
library(cBioPortalData)

# Inicialização da API do cBioPortal
cbio <- cBioPortal()
```

## Including Plots

Nesta fase é realizado o carregamento dos dados clinicos do estudo,  explorados os ensaios do estudo disponiveis e organizados em dataframes:

```{r pressure, echo=FALSE}
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas

# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder

# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra

# Summary dos dados
summary(bladder)

# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)

# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)

# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)

```

```{r}
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":", 
                                header = FALSE, 
                                row.names = 1, 
                                col.names = c("", "data")
                                )
meta_cna_hg19_seg

meta_cna <- read.delim("meta_cna.txt", sep = ":", 
                       header = FALSE, 
                       row.names = 1, 
                       col.names = c("", "data")
)
meta_cna

# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":", 
                         header = FALSE, 
                         row.names = 1, 
                         col.names = c("", "data")
                         )
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados


```


```{r}
# Alterar/corrigir nome de colunas
colnames(bladder_clin)[colnames(bladder_clin) == "SMOKIMG_STATUS"] <- "SMOKING_STATUS"
colnames(bladder_clin)[colnames(bladder_clin) == "patientId"] <- "PATIENT_ID"

# Verificar colunas com valores NA
colSums(is.na(bladder_clin)) # Verifica quandos valores NA cada coluna tem
print(colSums(is.na(bladder_clin))[colSums(is.na(bladder_clin)) > 0]) # Mostra quais as colunas têm valores NA

# # For Loop que vai procurar quais são as colunas numéricas
# numeric_columns <- c() # Inicializada uma lista vazia que irá conter as colunas numéricas
# for (col in names(bladder_clin)) {
#   if (is.numeric(bladder_clin[[col]])) {
#     numeric_columns <- c(numeric_columns, col)
#   }
# }
# print(numeric_columns) # Print das colunas numéricas

```
Determinar as variáveis para a Análise Estatística

```{r}
str(bladder_clin) # Verifica-se aqui que todas as colunas são do tipo chr (character)

# Conversão de colunas que possuem valores numéricas (no entanto não são) para serem numéricas
bladder_clin <- bladder_clin %>%
  mutate(
    SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
    AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
    FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
    MSI_SCORE = as.numeric(MSI_SCORE),
    MUTATION_COUNT = as.numeric(MUTATION_COUNT),
    SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
    TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
    TUMOR_PURITY = as.numeric(TUMOR_PURITY)
  )

# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]

# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot

ggsave("pairplot.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory

# Analisando o pairplot, podemos deduzir que as colunas que precisam de ser logaritmizadas são: 
# MSI_SCORE
# MUTATION_COUNT
# SAMPLE_COVERAGE
# TMB_NONSYNONYMOUS

```

Tratamento dos NAs
```{r}
# Tratamento dos NAs
# Remove todas as amostras que têm valores NA (remove 96% dos dados)
cleaned_data <- na.omit(bladder_clin)
cleaned_data

# Itera sobre cada coluna procura por valores NA, verifica se é coluna numérica e calcula a mediana, seguido de substituição dos NAs com a mediana dessa coluna. Se a coluna não for numérica, substitui os NAs por "Unknown"
for (col in names(bladder_clin)) {
  if (anyNA(bladder_clin[[col]])) {
    if (is.numeric(bladder_clin[[col]])) {
      median_val <- median(bladder_clin[[col]], na.rm = TRUE)
      bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
    } else {
      # Substitui valores NA nas colunas "character type" por "Unknown"
      bladder_clin[[col]][is.na(bladder_clin[[col]])] <- "Unknown"
    }
  }
}
```
Normalização dos dados
```{r}
# Normalização dos dados
# Definida uma função "function(x) para Min-Max Scaling
min_max_scaling <- function(x) {
  if(is.numeric(x)) {
    return ((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
  } else {
    return (x)
  }
}

# Min-Max Scaling é aplicada exclusivamente a colunas numéricas
normalized_numeric <- lapply(bladder_clin, min_max_scaling)
normalized_bladder_clin <- bladder_clin # Dataset com os dados normalizados

# Substituição dos valores das colunas numéricas com os seus valores normalizados
for (col in names(bladder_clin)) {
  if (is.numeric(bladder_clin[[col]])) {
    normalized_bladder_clin[[col]] <- normalized_numeric[[col]]
  }
}

```
Análise Estatística de Dados de Cancro da Bexiga

Definição das Variáveis com as.factor
```{r}

# Idade em que a Sequenciação foi Reportada (Anos)
age = as.factor(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS)

# Tipo de Cancro
cancer_type = as.factor(bladder_clin$CANCER_TYPE_DETAILED)

# Estado da Doença
disease_state = as.factor(bladder_clin$DISEASE_STATE)

# Tratamento com Erdafitinib
erdafitinib_treatment = as.factor(bladder_clin$ERDAFITINIB_TREATED)

# Estado de Sobrevivência Global desde o Tx com Erdafitinib
overall_status = as.factor(bladder_clin$ERDAFITINIB_TX_OS_STATUS)

# Estado Sem Progressão desde o Tx com Erdafitinib
progression_status = as.factor(bladder_clin$ERDAFITINIB_TX_PFS_STATUS)

# Painel de Genes
gene_panel = as.factor(bladder_clin$GENE_PANEL)

# Tipo MSI
msi_type = as.factor(bladder_clin$MSI_TYPE)

# Código Oncotree
oncotree_code = as.factor(bladder_clin$ONCOTREE_CODE)

# Raça
race = as.factor(bladder_clin$RACE)

# Classe da Amostra
sample_class = as.factor(bladder_clin$SAMPLE_CLASS)

# Sexo
sexo = as.factor(bladder_clin$SEX)

# Estado de Fumador
smoking_status = as.factor(bladder_clin$SMOKIMG_STATUS)

# Estado Somático
somatic_status = as.factor(bladder_clin$SOMATIC_STATUS)

```
## 1 Variáveis Numéricas

1.1. *Idade em que a Sequenciação foi Reportada (Anos)*
1.2. *Sobrevivência Global (Meses desde o Tx com Erdafitinib)*
1.3. *Sobrevivência Sem Progressão (Meses desde o Tx com Erdafitinib)*
1.4. *Sobrevivência Global em Meses desde o Sequenciamento*

Na análise dessas variáveis numéricas, começamos por:

1. **Remover valores ausentes e calcular estatísticas descritivas**:
    - Primeiro, os valores ausentes (NaNs) da coluna com variáveis numéricas são removidos do conjunto de dados.
    - Em seguida, são calculadas algumas estatísticas descritivas:
        - **Média dos valores da variável**: Calcula-se a média dos valores da variável presentes no conjunto de dados limpo.
        - **Mediana dos valores da variável**: Determina-se a mediana dos valores da variável.
        - **Desvio padrão dos valores da variável**: Calcula-se o desvio padrão dos valores da variável.
        - **Intervalo interquartílico (IQR)**: O IQR é a diferença entre o terceiro quartil (Q3) e o primeiro quartil (Q1) dos valores da variável.

2. **Barplot e boxplot**:
    - Um gráfico de barras (barplot) é criado para visualizar a distribuição dos valores da variável.
    - Um gráfico de caixa (boxplot) é gerado para mostrar a variação e os possíveis valores atípicos dos valores da variável.


1.1. Idade em que a Sequenciação foi Reportada (Anos)
```{r}
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))

# Desvio padrão
sd(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))

# Intervalo Interquartílico
IQR(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))

# Barplot e boxplot
barplot(table(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))
boxplot(as.numeric(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS),
        main = "Idade em que a Sequência foi Reportada (Anos)",
        xlab = "Idade", horizontal = TRUE)

```
1.2. Sobrevivência Global (Meses desde o Tx com Erdafitinib)
```{r}
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))

# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))

# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))

# Barplot e boxplot
barplot(table(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
boxplot(as.numeric(bladder_clin$ERDAFITINIB_TX_OS_MONTHS),
        main = "Sobrevivência Global (Meses desde o Tx com Erdafitinib)",
        xlab = "Meses", horizontal = TRUE)


```
1.3. Sobrevivência Sem Progressão (Meses desde o Tx com Erdafitinib)
```{r}
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))

# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))

# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))

# Barplot e boxplot
barplot(table(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
boxplot(as.numeric(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS), horizontal = T)

```
## 2. Variáveis Categóricas:

2.1. *Detalhes do Tipo de Câncro*
2.2. *Estado da Doença*
2.3. *Tratamento com Erdafitinibe*
2.4. *Status de Sobrevivência Global desde o Tratamento com Erdafitinibe*
2.5. *Status de Progressão Livre desde o Tratamento com Erdafitinibe*
2.6. *Raça*
2.7. *Classe da Amostra*
2.8. *Sexo*
2.9. *Status de Fumador*
2.10. *Status Somático*
2.11. *Tipo de MSI (Instabilidade de Microssatélites)*
2.12. *Código Oncotree*

Na análise dessas variáveis numéricas, começamos por:

1. **Gráfico de barras para visualizar as frequências absolutas**:
    - Um gráfico de barras é criado para representar a frequência absoluta de cada categoria presente nos dados.
   
2. **Cálculo das frequências absolutas e relativas**:
    - Primeiro, as frequências absolutas das diferentes categorias são calculadas.
    - Em seguida, as frequências relativas são obtidas dividindo as frequências absolutas pelo total de observações.

3. **Criação de um data frame com as frequências absolutas e relativas**:
    - Um data frame chamado `freq_data` é criado, contendo três colunas:
        - `Categoria`: Os nomes das diferentes categorias.
        - `Frequencia_Absoluta`: As frequências absolutas correspondentes.
        - `Frequencia_Relativa`: As frequências relativas correspondentes.

4. **Gráfico de barras para as frequências absolutas**:
    - Um novo gráfico de barras é gerado para representar as frequências absolutas das categorias.

5. **Gráfico de barras para as frequências relativas**:
    - Outro gráfico de barras é criado para mostrar a distribuição relativa das categorias.
    - O título do gráfico é "Distribuição Relativa por Categoria".
    - O eixo x é rotulado como "Categoria" e o eixo y é rotulado como "Frequência Relativa".

6. **Gráfico de pizza**:
    - Por fim, um gráfico de pizza é gerado para ilustrar a distribuição relativa das categorias.
    - Os rótulos das fatias da pizza incluem o nome da categoria e a porcentagem correspondente arredondada.

2.1. Detalhes do Tipo de Câncro
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$CANCER_TYPE_DETAILED), 
        main = "Frequência Absoluta por Tipo de Cancro",
        xlab = "Tipo de Câncer", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$CANCER_TYPE_DETAILED)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Tipo de Câncer",
        xlab = "Tipo de Câncer", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Tipo de Câncer",
        xlab = "Tipo de Câncer", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Tipo de Cancro",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)), cex = 0.8)
```
2.2. Estado da Doença
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$DISEASE_STATE), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$DISEASE_STATE)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
2.3. Tratamento com Erdafitinibe
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$ERDAFITINIB_TREATED), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$ERDAFITINIB_TREATED)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
2.4. Status de Sobrevivência Global desde o Tratamento com Erdafitinibe
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$ERDAFITINIB_TX_OS_STATUS), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$ERDAFITINIB_TX_OS_STATUS)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)), cex = 0.8)
```
2.5. Status de Progressão Livre desde o Tratamento com Erdafitinibe
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$ERDAFITINIB_TX_PFS_STATUS), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$ERDAFITINIB_TX_PFS_STATUS)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)), cex = 0.8)
```
2.6. Raça
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$RACE), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$RACE)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
2.8. Sexo
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$SEX), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$SEX)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
2.9. Status de Fumador
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$SMOKIMG_STATUS), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$SMOKIMG_STATUS)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
2.10. Status Somático
```{r}
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$SOMATIC_STATUS), 
        main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$SOMATIC_STATUS)
freq_rel <- prop.table(freq_abs)

# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
                        Frequencia_Absoluta = as.numeric(freq_abs),
                        Frequencia_Relativa = as.numeric(freq_rel))

# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
        xlab = "Categoria", ylab = "Frequência Absoluta")

# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
        xlab = "Categoria", ylab = "Frequência Relativa")

# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
    labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"), 
    col = rainbow(length(freq_rel)),
    cex = 0.8)
```
## 3. Variáveis Contínuas:

3.1. *Melhor Resposta ao Erdafitinib*
3.2. *Fração do Genoma Alterado*
3.3. *Contagem de Mutações*
3.4. *TMB*
3.5. *Pureza do Tumor*


Na análise dessas variáveis numéricas, começamos por:

1. **Resumo estatístico**: Utiliza a função `summary()` para calcular estatísticas descritivas, como mínimo, 1º quartil, mediana, média, 3º quartil e máximo da variável dependente. Os valores ausentes são removidos antes do cálculo (`na.omit()`).

2. **Desvio padrão**: Calcula o desvio padrão da variável dependente usando a função `sd()`. Novamente, os valores ausentes são removidos antes do cálculo.

3. **Intervalo interquartílico (IQR)**: Calcula o intervalo interquartílico da variável dependente usando a função `IQR()`. Os valores ausentes são removidos antes do cálculo.

4. **Visualização de frequência**: Plota um histograma de frequência dos valores da variável dependente usando a função `plot(table(...))`.

5. **Gráfico de caixa (boxplot)**: Cria um gráfico de caixa para visualizar a distribuição dos valores da variável dependente. Os valores ausentes são removidos antes de criar o gráfico.


3.1. Melhor Resposta ao Erdafitinib
```{r}
# Remover valores ausentes e calcular o valor minimo, 1º quartil, mediana, média, 3º quartil e valor máximo da variavel.
summary_best_response <- summary(na.omit(bladder_clin$BEST_RESPONSE))
# Visualizar os valores
summary_best_response

# Remover valores ausentes e calcular o desvio padrão da variavel.
sd_best_response <- sd(na.omit(bladder_clin$BEST_RESPONSE))
# Visualizar o valor
sd_best_response

# Remover valores ausentes e calcular o Intervalo interquartilico.
IQR_best_response <- IQR(na.omit(bladder_clin$BEST_RESPONSEb))
# Visualizar o valor
IQR_best_response

plot(table(bladder_clin$BEST_RESPONSE))

# Criar o gráfico de caixa
boxplot(na.omit(bladder_clin$BEST_RESPONSE),  
        main = "Melhor resposta ao Erdafitinib",   
        xlab = "Melhor Resposta",                 
        horizontal = TRUE)                       
```
3.2. Fração do Genoma Alterado
```{r}
# Remover valores ausentes e calcular o valor minimo, 1º quartil, mediana, média, 3º quartil e valor máximo da variavel.
summary_ <- summary(na.omit(bladder_clin$FRACTION_GENOME_ALTERED))
# Visualizar os valores
summary_

# Remover valores ausentes e calcular o desvio padrão da variavel.
sd_ <- sd(na.omit(bladder_clin$FRACTION_GENOME_ALTERED))
# Visualizar o valor
sd_

# Remover valores ausentes e calcular o Intervalo interquartilico.
IQR_ <- IQR(na.omit(bladder_clin$FRACTION_GENOME_ALTERED))
# Visualizar o valor
IQR_

# Calcular a variância
var_ <- var(na.omit(bladder_clin$FRACTION_GENOME_ALTERED))

# Visualizar o valor da variância
var_

# Criar o gráfico de caixa
# Filtrar os dados nao numericos
filtered_data <- bladder_clin[complete.cases(bladder_clin$FRACTION_GENOME_ALTERED), ]
boxplot(filtered_data$FRACTION_GENOME_ALTERED, horizontal=T)
```
3.3. Contagem de Mutações
```{r}
# Remover valores ausentes e calcular o valor minimo, 1º quartil, mediana, média, 3º quartil e valor máximo da variavel.
summary_ <- summary(na.omit(bladder_clin$MUTATION_COUNT))
# Visualizar os valores
summary_

# Remover valores ausentes e calcular o desvio padrão da variavel.
sd_ <- sd(na.omit(bladder_clin$MUTATION_COUNT))
# Visualizar o valor
sd_

# Remover valores ausentes e calcular o Intervalo interquartilico.
IQR_ <- IQR(na.omit(bladder_clin$MUTATION_COUNT))
# Visualizar o valor
IQR_

# Calcular a variância
var_ <- var(na.omit(bladder_clin$MUTATION_COUNT))

# Visualizar o valor da variância
var_

barplot(table(bladder_clin$MUTATION_COUNT))

# Criar o gráfico de caixa
boxplot(bladder_msk_2023_clinical_data$"Mutation.Count", horizontal=T)
```
