sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4))
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
View(bladder_clin)
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2)),
lower = list(continuous = wrap("points", size = 1, color = "blue"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4))
pairplot
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.5, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4))
pairplot
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT))
View(bladder_clin)
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE))
## Inicialização do API cBioPortal e obtenção dos dados do estudo "blca_msk_tcga_2020"
# Define a working directory deste ficheiro para à diretoria atual dela automáticamente
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Informações (Descrição, citação e PubMed ID do artigo) presentes no ficheiro "meta_study.txt"
meta_study <- read.delim("blca_msk_tcga_2020\\meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["description", "data"] # Descrição
meta_study["citation", "data"]    # Citação
meta_study["pmid", "data"]        # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
SAMPLE_COUNT = as.numeric(SAMPLE_COUNT)
)
# Vamos substituir os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown". Define-se primeiro as colunas numéricas para conseguirmos correr o nosso código de substituição dos NAs.
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores:
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
# Estudando as colunas, verifica-se que as colunas "SAMPLE_COUNT" e "CANCER_TYPE" são desnecessárias pois todas as linhas em ambas assumem os mesmos valores, logo são removidas:
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE))
knitr::opts_chunk$set(echo = TRUE)
# Instalação dos pacotes necessários
### Só é necessário correr este código se os pacotes ainda não foram instalados ou se estão desatualizados! Caso já estejam, podem saltar para o carregamento dos pacotes! ###
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("cBioPortalData", "edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db","org.Hs.eg.db", "TCGAbiolinks", "DESeq2", "clusterProfiler"), ask = FALSE)
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Instalação dos pacotes necessários
### Só é necessário correr este código se os pacotes ainda não foram instalados ou se estão desatualizados! Caso já estejam, podem saltar para o carregamento dos pacotes! ###
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("cBioPortalData", "edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db","org.Hs.eg.db", "TCGAbiolinks", "DESeq2", "clusterProfiler", "EnhancedVolcano"), ask = FALSE)
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Carregamento dos pacotes
library(cBioPortalData)
library(edgeR)
library(limma)
library(DESeq2)
library(GGally)
library(dplyr)
library(tibble)
library(TCGAbiolinks)
library(clusterProfiler)
library(org.Hs.eg.db)
## Inicialização do API cBioPortal e obtenção dos dados do estudo "blca_msk_tcga_2020"
# Define a working directory deste ficheiro para à diretoria atual dela automáticamente
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Informações (Descrição, citação e PubMed ID do artigo) presentes no ficheiro "meta_study.txt"
meta_study <- read.delim("blca_msk_tcga_2020\\meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["description", "data"] # Descrição
meta_study["citation", "data"]    # Citação
meta_study["pmid", "data"]        # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
View(meta_study)
# Informações (Descrição, citação e PubMed ID do artigo) presentes no ficheiro "meta_study.txt"
meta_study <- read.delim("blca_msk_tcga_2020\\meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
# Remove leading white spaces from the "data" column
meta_study$data <- trimws(meta_study$data)
meta_study["description", "data"] # Descrição
meta_study["citation", "data"]    # Citação
meta_study["pmid", "data"]        # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
View(meta_study)
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
SAMPLE_COUNT = as.numeric(SAMPLE_COUNT)
)
# Vamos substituir os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown". Define-se primeiro as colunas numéricas para conseguirmos correr o nosso código de substituição dos NAs.
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores:
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
# Estudando as colunas, verifica-se que as colunas "SAMPLE_COUNT", "CANCER_TYPE", "CANCER_TYPE_DETAILED", "ONCOTREE_CODE" e "SOMATIC_STATUS" têm sempre 1 único valor cada, logo serão removidas.
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE, CANCER_TYPE_DETAILED, ONCOTREE_CODE, SOMATIC_STATUS))
View(bladder_clin)
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.5, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4))
pairplot
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.5, "lines")) # Adjust panel spacing
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Adjust panel spacing
pairplot
ggsave("pairplot_blca.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Adjust panel spacing
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 8) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 4, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 8) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 8, height = 6) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 9, height = 7) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 9, height = 9) # Guarda o pairplot como uma imagem .png no working directory, caso queiram ver o gráfico, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Este código é puramente opcional e podemos evitar corrê-lo, ele não tem quaisquer inteferências com os códigos seguintes! ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
# Custom function to determine box color based on correlation value
get_corr_color <- function(x) {
ifelse(abs(x) >= 0.7, "green",
ifelse(abs(x) >= 0.5, "yellow",
ifelse(abs(x) >= 0.3, "orange", "white")))
}
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data,
upper = list(continuous = wrap("cor", size = 2, color = "brown",
fill = get_corr_color)),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# Tratamento de NAs e transformação de dados categóricos
bladder_clin <- bladder_clin %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS, SAMPLE_COUNT), as.numeric))
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# Tratamento de NAs e transformação de dados categóricos
bladder_clin <- bladder_clin %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
colData(data)
