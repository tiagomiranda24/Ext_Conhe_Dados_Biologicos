library(limma)
library(DESeq2)
library(GGally)
library(dplyr)
library(tibble)
library(TCGAbiolinks)
library(clusterProfiler)
library(org.Hs.eg.db)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
SAMPLE_COUNT = as.numeric(SAMPLE_COUNT)
)
# Substitui-se os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown"
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
# Se o código correu bem, as colunas numéricas não vão ter "NA's" e as colunas não munéricas vão ter "Unknown" em vez de "NA's", evitando problemas nos gráficos
summary(bladder_clin)
################ Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ##############################
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# Tratamento de NAs e transformação de dados categóricos
bladder_clin <- bladder_clin %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS, SAMPLE_COUNT), as.numeric))
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
knitr::opts_chunk$set(echo = TRUE)
# Instalação dos pacotes necessários
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("cBioPortalData", "edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db","org.Hs.eg.db", "TCGAbiolinks", "DESeq2", "clusterProfiler"), ask = FALSE)
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Carregamento dos pacotes
library(cBioPortalData)
library(edgeR)
library(limma)
library(DESeq2)
library(GGally)
library(dplyr)
library(tibble)
library(TCGAbiolinks)
library(clusterProfiler)
library(org.Hs.eg.db)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
SAMPLE_COUNT = as.numeric(SAMPLE_COUNT)
)
# Substitui-se os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown"
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
# Se o código correu bem, as colunas numéricas não vão ter "NA's" e as colunas não munéricas vão ter "Unknown" em vez de "NA's", evitando problemas nos gráficos
summary(bladder_clin)
################ Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ##############################
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# Tratamento de NAs e transformação de dados categóricos
bladder_clin <- bladder_clin %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS, SAMPLE_COUNT), as.numeric))
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
getwd()
colData(data)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
knitr::opts_chunk$set(echo = TRUE)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
knitr::opts_chunk$set(echo = TRUE)
# Instalação dos pacotes necessários
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c("cBioPortalData", "edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db","org.Hs.eg.db", "TCGAbiolinks", "DESeq2", "clusterProfiler"), ask = FALSE)
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Carregamento dos pacotes
library(cBioPortalData)
library(edgeR)
library(limma)
library(DESeq2)
library(GGally)
library(dplyr)
library(tibble)
library(TCGAbiolinks)
library(clusterProfiler)
library(org.Hs.eg.db)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
SAMPLE_COUNT = as.numeric(SAMPLE_COUNT)
)
# Substitui-se os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown"
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
CANCER_TYPE = as.factor(CANCER_TYPE),
CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Verificar se ainda há valores NA
# Se o código correu bem, as colunas numéricas não vão ter "NA's" e as colunas não munéricas vão ter "Unknown" em vez de "NA's", evitando problemas nos gráficos
summary(bladder_clin)
################ Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ##############################
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# Tratamento de NAs e transformação de dados categóricos
bladder_clin <- bladder_clin %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS, SAMPLE_COUNT), as.numeric))
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
if (!file.exists("GDCdata/TCGA-ACC/Transcriptome_Profiling/Gene_Expression_Quantification")) {
dir.create("GDCdata/TCGA-ACC/Transcriptome_Profiling/Gene_Expression_Quantification", recursive = TRUE)
}
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
# Define o projeto
project <- "TCGA-ACC"
# Configura a consulta com o tipo de amostra correto
query <- GDCquery(project = project,
data.category = "Transcriptome Profiling",
data.type = "Gene Expression Quantification",
workflow.type = "STAR - Counts",
sample.type = "Primary Tumor")
# Baixa os dados
GDCdownload(query)
# Prepara os dados para análise
data <- GDCprepare(query)
knitr::opts_chunk$set(echo = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"), ask = FALSE)
# Instalação dos pacotes "GGally" e "tibble"
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
if (!requireNamespace("tibble", quietly = TRUE)) {
install.packages("tibble")
}
# Carrega os pacotes instalados/necessários
library(edgeR)
library(limma)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
