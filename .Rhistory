xlab = "Categoria", ylab = "Frequência Absoluta")
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$SMOKING_STATUS),
main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$SMOKIMG_STATUS)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$SOMATIC_STATUS),
main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$SOMATIC_STATUS)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
xlab = "Categoria", ylab = "Frequência Relativa")
# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"),
col = rainbow(length(freq_rel)),
cex = 0.8)
# Remover valores ausentes e calcular o valor minimo, 1º quartil, mediana, média, 3º quartil e valor máximo da variavel.
summary_best_response <- summary(na.omit(bladder_clin$BEST_RESPONSE))
# Visualizar os valores
summary_best_response
# Remover valores ausentes e calcular o desvio padrão da variavel.
sd_best_response <- sd(na.omit(bladder_clin$BEST_RESPONSE))
# Visualizar o valor
sd_best_response
# Remover valores ausentes e calcular o Intervalo interquartilico.
IQR_best_response <- IQR(na.omit(bladder_clin$BEST_RESPONSEb))
# Visualizar o valor
IQR_best_response
plot(table(bladder_clin$BEST_RESPONSE))
# Criar o gráfico de caixa
boxplot(na.omit(bladder_clin$BEST_RESPONSE),
main = "Melhor resposta ao Erdafitinib",
xlab = "Melhor Resposta",
horizontal = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"))
# Instalação dos pacotes "GGally" e "tibble"
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
if (!require(tibble)) {
install.packages("tibble")
}
# Carrega os pacotes instalados/necessários
library(edgeR)
library(limma)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
cbio <- cBioPortal()
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"), ask = FALSE)
# Instalação dos pacotes "GGally" e "tibble"
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
if (!requireNamespace("tibble", quietly = TRUE)) {
install.packages("tibble")
}
# Carrega os pacotes instalados/necessários
library(edgeR)
library(limma)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
knitr::opts_chunk$set(echo = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"), ask = FALSE)
# Instalação dos pacotes "GGally" e "tibble"
if (!requireNamespace("GGally", quietly = TRUE))
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
if (!requireNamespace("tibble", quietly = TRUE)) {
install.packages("tibble")
}
# Carrega os pacotes instalados/necessários
library(edgeR)
library(limma)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)
# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)
# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Alterar/corrigir nome de colunas
colnames(bladder_clin)[colnames(bladder_clin) == "SMOKIMG_STATUS"] <- "SMOKING_STATUS"
colnames(bladder_clin)[colnames(bladder_clin) == "patientId"] <- "PATIENT_ID"
# Verificar colunas com valores NA
colSums(is.na(bladder_clin)) # Verifica quandos valores NA cada coluna tem
print(colSums(is.na(bladder_clin))[colSums(is.na(bladder_clin)) > 0]) # Mostra quais as colunas têm valores NA
str(bladder_clin) # Verifica-se aqui que todas as colunas são do tipo chr (character)
# Conversão de colunas que possuem valores numéricas (no entanto não são) para serem numéricas
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot
ggsave("pairplot.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory
# Analisando o pairplot, podemos deduzir que as colunas que precisam de ser logaritmizadas são:
# MSI_SCORE
# MUTATION_COUNT
# SAMPLE_COVERAGE
# TMB_NONSYNONYMOUS
# Tratamento dos NAs
cleaned_data <- na.omit(bladder_clin) # Criação de um novo dataset que exclui todas as amostras com valores NA (96% dos dados)
cleaned_data
# Itera sobre cada coluna procura por valores NA, verifica se é coluna numérica e calcula a mediana, seguido de substituição dos NAs com a mediana dessa coluna. Se a coluna não for numérica, substitui os NAs por "Unknown"
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
if (is.numeric(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
} else {
# Substitui valores NA nas colunas "character type" por "Unknown"
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- "Unknown"
}
}
}
bladder_clin
# Normalização dos dados
# Definida uma função "function(x) para Min-Max Scaling
min_max_scaling <- function(x) {
if(is.numeric(x)) {
return ((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
} else {
return (x)
}
}
# Min-Max Scaling é aplicada exclusivamente a colunas numéricas
normalized_numeric <- lapply(bladder_clin, min_max_scaling)
normalized_bladder_clin <- bladder_clin # Dataset com os dados normalizados
# Substituição dos valores das colunas numéricas com os seus valores normalizados
for (col in names(bladder_clin)) {
if (is.numeric(bladder_clin[[col]])) {
normalized_bladder_clin[[col]] <- normalized_numeric[[col]]
}
}
# Idade em que a Sequenciação foi Reportada (Anos)
age = as.factor(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS)
# Tipo de Cancro
cancer_type = as.factor(bladder_clin$CANCER_TYPE_DETAILED)
# Estado da Doença
disease_state = as.factor(bladder_clin$DISEASE_STATE)
# Tratamento com Erdafitinib
erdafitinib_treatment = as.factor(bladder_clin$ERDAFITINIB_TREATED)
# Estado de Sobrevivência Global desde o Tx com Erdafitinib
overall_status = as.factor(bladder_clin$ERDAFITINIB_TX_OS_STATUS)
# Estado Sem Progressão desde o Tx com Erdafitinib
progression_status = as.factor(bladder_clin$ERDAFITINIB_TX_PFS_STATUS)
# Painel de Genes
gene_panel = as.factor(bladder_clin$GENE_PANEL)
# Tipo MSI
msi_type = as.factor(bladder_clin$MSI_TYPE)
# Código Oncotree
oncotree_code = as.factor(bladder_clin$ONCOTREE_CODE)
# Raça
race = as.factor(bladder_clin$RACE)
# Classe da Amostra
sample_class = as.factor(bladder_clin$SAMPLE_CLASS)
# Sexo
sexo = as.factor(bladder_clin$SEX)
# Estado de Fumador
smoking_status = as.factor(bladder_clin$SMOKIMG_STATUS)
# Estado Somático
somatic_status = as.factor(bladder_clin$SOMATIC_STATUS)
str(bladder_clin) # Verifica-se aqui que todas as colunas são do tipo chr (character)
# Conversão de colunas que possuem valores numéricas (no entanto não são) para serem numéricas
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot
ggsave("pairplot.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory
# Analisando o pairplot, podemos deduzir que as colunas que precisam de ser logaritmizadas são:
# MSI_SCORE
# MUTATION_COUNT
# SAMPLE_COVERAGE
# TMB_NONSYNONYMOUS
# Tratamento dos NAs
cleaned_data <- na.omit(bladder_clin) # Criação de um novo dataset que exclui todas as amostras com valores NA (96% dos dados)
cleaned_data
# Itera sobre cada coluna procura por valores NA, verifica se é coluna numérica e calcula a mediana, seguido de substituição dos NAs com a mediana dessa coluna. Se a coluna não for numérica, substitui os NAs por "Unknown"
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
if (is.numeric(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
} else {
# Substitui valores NA nas colunas "character type" por "Unknown"
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- "Unknown"
}
}
}
bladder_clin
# Normalização dos dados
# Definida uma função "function(x) para Min-Max Scaling
min_max_scaling <- function(x) {
if(is.numeric(x)) {
return ((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
} else {
return (x)
}
}
# Min-Max Scaling é aplicada exclusivamente a colunas numéricas
normalized_numeric <- lapply(bladder_clin, min_max_scaling)
normalized_bladder_clin <- bladder_clin # Dataset com os dados normalizados
# Substituição dos valores das colunas numéricas com os seus valores normalizados
for (col in names(bladder_clin)) {
if (is.numeric(bladder_clin[[col]])) {
normalized_bladder_clin[[col]] <- normalized_numeric[[col]]
}
}
# Idade em que a Sequenciação foi Reportada (Anos)
age = as.factor(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS)
# Tipo de Cancro
cancer_type = as.factor(bladder_clin$CANCER_TYPE_DETAILED)
# Estado da Doença
disease_state = as.factor(bladder_clin$DISEASE_STATE)
# Tratamento com Erdafitinib
erdafitinib_treatment = as.factor(bladder_clin$ERDAFITINIB_TREATED)
# Estado de Sobrevivência Global desde o Tx com Erdafitinib
overall_status = as.factor(bladder_clin$ERDAFITINIB_TX_OS_STATUS)
# Estado Sem Progressão desde o Tx com Erdafitinib
progression_status = as.factor(bladder_clin$ERDAFITINIB_TX_PFS_STATUS)
# Painel de Genes
gene_panel = as.factor(bladder_clin$GENE_PANEL)
# Tipo MSI
msi_type = as.factor(bladder_clin$MSI_TYPE)
# Código Oncotree
oncotree_code = as.factor(bladder_clin$ONCOTREE_CODE)
# Raça
race = as.factor(bladder_clin$RACE)
# Classe da Amostra
sample_class = as.factor(bladder_clin$SAMPLE_CLASS)
# Sexo
sexo = as.factor(bladder_clin$SEX)
# Estado de Fumador
smoking_status = as.factor(bladder_clin$SMOKING_STATUS)
# Estado Somático
somatic_status = as.factor(bladder_clin$SOMATIC_STATUS)
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))
# Desvio padrão
sd(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))
# Intervalo Interquartílico
IQR(na.omit(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))
# Barplot e boxplot
barplot(table(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS))
boxplot(as.numeric(bladder_clin$AGE_AT_SEQ_REPORTED_YEARS),
main = "Idade em que a Sequência foi Reportada (Anos)",
xlab = "Idade", horizontal = TRUE)
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_OS_MONTHS), na.rm = TRUE)
# Barplot e boxplot
barplot(table(bladder_clin$ERDAFITINIB_TX_OS_MONTHS))
boxplot(as.numeric(bladder_clin$ERDAFITINIB_TX_OS_MONTHS),
main = "Sobrevivência Global (Meses desde o Tx com Erdafitinib)",
xlab = "Meses", horizontal = TRUE)
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
# Remover valores ausentes e calcular estatísticas descritivas
summary(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
# Desvio padrão
sd(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
# Intervalo Interquartílico
IQR(na.omit(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS), na.rm = TRUE)
# Barplot e boxplot
barplot(table(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS))
boxplot(as.numeric(bladder_clin$ERDAFITINIB_TX_PFS_MONTHS), horizontal = T)
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$CANCER_TYPE_DETAILED),
main = "Frequência Absoluta por Tipo de Cancro",
xlab = "Tipo de Câncer", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$CANCER_TYPE_DETAILED)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Tipo de Câncer",
xlab = "Tipo de Câncer", ylab = "Frequência Absoluta")
# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Tipo de Câncer",
xlab = "Tipo de Câncer", ylab = "Frequência Relativa")
# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Tipo de Cancro",
labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"),
col = rainbow(length(freq_rel)), cex = 0.8)
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$CANCER_TYPE_DETAILED),
main = "Frequência Absoluta por Tipo de Cancro",
xlab = "Tipo de Cancro", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$CANCER_TYPE_DETAILED)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Tipo de Cancro",
xlab = "Tipo de Cancro", ylab = "Frequência Absoluta")
# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Tipo de Cancro",
xlab = "Tipo de Cancro", ylab = "Frequência Relativa")
# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Tipo de Cancro",
labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"),
col = rainbow(length(freq_rel)), cex = 0.8)
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$DISEASE_STATE),
main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$DISEASE_STATE)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
xlab = "Categoria", ylab = "Frequência Relativa")
# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"),
col = rainbow(length(freq_rel)),
cex = 0.8)
# Gráfico de barras para visualizar as frequências absolutas
barplot(table(bladder_clin$ERDAFITINIB_TREATED),
main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Calcular as frequências absolutas e relativas
freq_abs <- table(bladder_clin$ERDAFITINIB_TREATED)
freq_rel <- prop.table(freq_abs)
# Criar um data frame com as frequências absolutas e relativas
freq_data <- data.frame(Categoria = names(freq_abs),
Frequencia_Absoluta = as.numeric(freq_abs),
Frequencia_Relativa = as.numeric(freq_rel))
# Gráfico de barras para as frequências absolutas
barplot(freq_abs, main = "Frequência Absoluta por Categoria",
xlab = "Categoria", ylab = "Frequência Absoluta")
# Gráfico de barras para as frequências relativas
barplot(freq_rel, main = "Distribuição Relativa por Categoria",
xlab = "Categoria", ylab = "Frequência Relativa")
# Criar o gráfico de pizza
pie(freq_rel, main = "Distribuição Relativa por Categoria",
labels = paste(names(freq_rel), ": ", round(freq_rel * 100, 2), "%"),
col = rainbow(length(freq_rel)),
cex = 0.8)
