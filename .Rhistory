col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation","data"] # Citação
meta_study["pmid","data"] # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# library("ggplot2")
# library("GGally")
#
#
# # Subset the dataset to include only numeric columns
# numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
#
# # Create a pairplot with only numeric columns
# GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
View(bladder_clin)
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subset the dataset to include only numeric columns
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Create a pairplot with only numeric columns
GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subset the dataset to include only numeric columns
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Create a pairplot with only numeric columns
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot
View(pairplot)
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subset the dataset to include only numeric columns
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Create a pairplot with only numeric columns
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
print(pairplot)
View(pairplot)
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subset the dataset to include only numeric columns
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Create a pairplot with only numeric columns
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot
ggsave("pairplot.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory
knitr::opts_chunk$set(echo = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"))
# Instalação dos pacotes "GGally" e "tibble"
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
#install.packages("tibble")
# Carrega os pacotes instalados
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)
# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)
# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)
# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)
# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
View(bladder_clin)
knitr::opts_chunk$set(echo = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"))
# Instalação dos pacotes "GGally" e "tibble"
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
#install.packages("tibble")
# Carrega os pacotes instalados
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(tidyverse)
library(ggplot2)
library(GGally)
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
library(tibble)
library(dplyr)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)
# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)
# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Verificar colunas com valores NA
colSums(is.na(bladder_clin)) # Verifica quandos valores NA cada coluna tem
print(colSums(is.na(bladder_clin))[colSums(is.na(bladder_clin)) > 0]) # Mostra quais as colunas têm valores NA
# Get the column names of bladder_clin
column_names <- names(bladder_clin)
# Initialize an empty list to store numeric columns
numeric_columns <- c()
# Loop through each column and check if it contains numeric values
for (col in column_names) {
if (is.numeric(bladder_clin[[col]])) {
numeric_columns <- c(numeric_columns, col)
}
}
# Print the list of numeric columns
print(numeric_columns)
View(bladder_clin)
cleaned_data
# Tratamento dos NAs
# bladder_clin <- na.omit(bladder_clin)
# bladder_clin
# Replace NA values with median of the column
cleaned_data <- bladder_clin
cleaned_data$column_name[is.na(cleaned_data$column_name)] <- median(cleaned_data$column_name, na.rm = TRUE)
cleaned_data
View(cleaned_data)
# Tratamento dos NAs
cleaned_data <- na.omit(bladder_clin)
cleaned_data
# Replace NA values with median of the column
# cleaned_data <- bladder_clin
# cleaned_data$column_name[is.na(cleaned_data$column_name)] <- median(cleaned_data$column_name, na.rm = TRUE)
# cleaned_data
View(cleaned_data)
# Tratamento dos NAs
# Remove todas as amostras que têm valores NA (remove 96% dos dados)
# cleaned_data <- na.omit(bladder_clin)
# cleaned_data
# Replace NA values with median of the column
# cleaned_data <- bladder_clin
# cleaned_data$column_name[is.na(cleaned_data$column_name)] <- median(cleaned_data$column_name, na.rm = TRUE)
# cleaned_data
# Itera sobre cada coluna, procura por valores NA, calcula a mediana de cada coluna e substitui os NAs com a mediana dessa coluna
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
}
}
View(bladder_clin)
knitr::opts_chunk$set(echo = TRUE)
# Instalação e carregamento dos pacotes necessários
# Verifica se o BiocManager está instalado e instala se necessário
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
# Verifica se o pacote cBioPortalData está instalado e instala se necessário
if (!requireNamespace("cBioPortalData", quietly = TRUE))
BiocManager::install("cBioPortalData")
BiocManager::install(c("edgeR", "limma", "Glimma", "gplots", "org.Mm.eg.db", "RColorBrewer", "TCGAbiolinks", "DESeq2"))
# Instalação dos pacotes "GGally" e "tibble"
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
#install.packages("tibble")
# Carrega os pacotes instalados
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(tidyverse)
library(ggplot2)
library(GGally)
library(tibble)
library(dplyr)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(DESeq2)
# Carregamento do pacote cBioPortalData
library(cBioPortalData)
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
install.packages("GGally", dependencies = TRUE, repos = "https://CRAN.R-project.org/")
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "bladder_msk_2023")
bladder_clin
dim(bladder_clin)  # Deve retornar 526 linhas e 29 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("bladder_msk_2023", ask = FALSE)
bladder
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
# names(rowData(bladder)) # tipos de metadados associados a cada gene
# names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Acessando os dados de cna e convertendo para um dataframe
dados_cna = assays(bladder)$cna
dados_cna_df = as.data.frame(dados_cna)
# Acessando os dados de cna_hg19 e convertendo para um dataframe
dados_cna_hg19 = assays(bladder)$cna_hg19.seg
dados_cna_hg19_df = as.data.frame(dados_cna_hg19)
# Acessando os dados de mutação e convertendo para um dataframe
dados_mutacao = assays(bladder)$mutations
dados_mutacao_df = as.data.frame(dados_mutacao)
# Extração dos Metadados
# Aceder aos ficheiros dos metadados (formato .txt) presentes dentro da pasta "bladder_msk_2023"
setwd("bladder_msk_2023")
meta_cna_hg19_seg <- read.delim("meta_cna_hg19_seg.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna_hg19_seg
meta_cna <- read.delim("meta_cna.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_cna
# Metadados do estudo
meta_study <- read.delim("meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study["citation", "data"] # Citação
meta_study["pmid", "data"]     # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Verificar colunas com valores NA
colSums(is.na(bladder_clin)) # Verifica quandos valores NA cada coluna tem
print(colSums(is.na(bladder_clin))[colSums(is.na(bladder_clin)) > 0]) # Mostra quais as colunas têm valores NA
# Get the column names of bladder_clin
column_names <- names(bladder_clin)
# Initialize an empty list to store numeric columns
numeric_columns <- c()
# Loop through each column and check if it contains numeric values
for (col in column_names) {
if (is.numeric(bladder_clin[[col]])) {
numeric_columns <- c(numeric_columns, col)
}
}
# Print the list of numeric columns
print(numeric_columns)
str(bladder_clin) # as colunas são todas do tipo chr (character)
library(dplyr)
# Convert specific columns to numeric
bladder_clin <- bladder_clin %>%
mutate(
SEQUENCING_OS_MONTHS = as.numeric(SEQUENCING_OS_MONTHS),
AGE_AT_SEQ_REPORTED_YEARS = as.numeric(AGE_AT_SEQ_REPORTED_YEARS),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE = as.numeric(MSI_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
SAMPLE_COVERAGE = as.numeric(SAMPLE_COVERAGE),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
TUMOR_PURITY = as.numeric(TUMOR_PURITY)
)
# Subset the dataset to include only numeric columns
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Create a pairplot with only numeric columns
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf)
pairplot
ggsave("pairplot.png", pairplot) # Guarda o pairplot como uma imagem .png no working directory
# Analisando o pairplot, podemos deduzir que as colunas que precisam de ser logaritmizadas são:
# MSI_SCORE
# MUTATION_COUNT
# SAMPLE_COVERAGE
# TMB_NONSYNONYMOUS
# Tratamento dos NAs
# Remove todas as amostras que têm valores NA (remove 96% dos dados)
# cleaned_data <- na.omit(bladder_clin)
# cleaned_data
# Replace NA values with median of the column
# cleaned_data <- bladder_clin
# cleaned_data$column_name[is.na(cleaned_data$column_name)] <- median(cleaned_data$column_name, na.rm = TRUE)
# cleaned_data
# Itera sobre cada coluna, procura por valores NA, calcula a mediana de cada coluna e substitui os NAs com a mediana dessa coluna
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
}
}
View(bladder_clin)
# Tratamento dos NAs
# Remove todas as amostras que têm valores NA (remove 96% dos dados)
# cleaned_data <- na.omit(bladder_clin)
# cleaned_data
# Replace NA values with median of the column
# cleaned_data <- bladder_clin
# cleaned_data$column_name[is.na(cleaned_data$column_name)] <- median(cleaned_data$column_name, na.rm = TRUE)
# cleaned_data
# Itera sobre cada coluna procura por valores NA, verifica se é coluna numérica e calcula a mediana, seguido de substituição dos NAs com a mediana dessa coluna. Se a coluna não for numérica, substitui os NAs por "Unknown"
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
if (is.numeric(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
} else {
# Substitui valores NA nas colunas "character type" por "Unknown"
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- "Unknown"
}
}
}
View(bladder_clin)
# Tratamento dos NAs
# Remove todas as amostras que têm valores NA (remove 96% dos dados)
cleaned_data <- na.omit(bladder_clin)
cleaned_data
# Itera sobre cada coluna procura por valores NA, verifica se é coluna numérica e calcula a mediana, seguido de substituição dos NAs com a mediana dessa coluna. Se a coluna não for numérica, substitui os NAs por "Unknown"
for (col in names(bladder_clin)) {
if (anyNA(bladder_clin[[col]])) {
if (is.numeric(bladder_clin[[col]])) {
median_val <- median(bladder_clin[[col]], na.rm = TRUE)
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- median_val
} else {
# Substitui valores NA nas colunas "character type" por "Unknown"
bladder_clin[[col]][is.na(bladder_clin[[col]])] <- "Unknown"
}
}
}
