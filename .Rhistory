# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# # Tratamento de NAs e transformação de dados categóricos
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
#
# # Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
#                   FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
#                   TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
# Aplicada a logaritmização e min-max scaling aos dados mRNA
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
dplyr::last_dplyr_warnings()
View(bladder_clin)
## Inicialização do API cBioPortal e obtenção dos dados do estudo "blca_msk_tcga_2020"
# Automáticamente define a working directory para o local do ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
View(bladder_clin)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Informações (Descrição, citação e PubMed ID do artigo) presentes no ficheiro "meta_study.txt"
meta_study <- read.delim("blca_msk_tcga_2020\\meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study$data <- trimws(meta_study$data) # Remove leading spaces na coluna "data"
meta_study["description", "data"] # Descrição
meta_study["citation", "data"]    # Citação
meta_study["pmid", "data"]        # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Para verificar as classes das colunas do conjunto de dados:
unlist(lapply(bladder_clin, class))
# Para verificar os tipos das colunas do conjunto de dados:
unlist(lapply(bladder_clin, typeof))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
#SAMPLE_COUNT = as.numeric(SAMPLE_COUNT),
)
# Vamos substituir os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown". Define-se primeiro as colunas numéricas para conseguirmos correr o nosso código de substituição dos NAs.
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores:
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
#CANCER_TYPE = as.factor(CANCER_TYPE),
#CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
#ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
#SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Estudando as colunas, verifica-se que as colunas "SAMPLE_COUNT", "CANCER_TYPE", "CANCER_TYPE_DETAILED", "ONCOTREE_CODE" e "SOMATIC_STATUS" têm sempre 1 único valor cada, logo serão removidas.
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE, CANCER_TYPE_DETAILED, ONCOTREE_CODE, SOMATIC_STATUS))
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Logaritmização das colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS),
~ if(all(. >= 0)) log(. + 1) else .))
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# # Tratamento de NAs e transformação de dados categóricos
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
#
# # Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
#                   FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
#                   TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
# Aplicada a logaritmização e min-max scaling aos dados mRNA
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
### Aqui vamos observar os estados, distribuições e correlações dos nossos dados, incluindo entender o que podemos fazer para normalização dos dados. ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
## Inicialização do API cBioPortal e obtenção dos dados do estudo "blca_msk_tcga_2020"
# Automáticamente define a working directory para o local do ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Informações (Descrição, citação e PubMed ID do artigo) presentes no ficheiro "meta_study.txt"
meta_study <- read.delim("blca_msk_tcga_2020\\meta_study.txt", sep = ":",
header = FALSE,
row.names = 1,
col.names = c("", "data")
)
meta_study$data <- trimws(meta_study$data) # Remove leading spaces na coluna "data"
meta_study["description", "data"] # Descrição
meta_study["citation", "data"]    # Citação
meta_study["pmid", "data"]        # pmid (PubMed ID), permite encontrar o artigo da qual originaram os dados
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
#SAMPLE_COUNT = as.numeric(SAMPLE_COUNT),
)
# Vamos substituir os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown". Define-se primeiro as colunas numéricas para conseguirmos correr o nosso código de substituição dos NAs.
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores:
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
#CANCER_TYPE = as.factor(CANCER_TYPE),
#CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
#ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
#SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Estudando as colunas, verifica-se que as colunas "SAMPLE_COUNT", "CANCER_TYPE", "CANCER_TYPE_DETAILED", "ONCOTREE_CODE" e "SOMATIC_STATUS" têm sempre 1 único valor cada, logo serão removidas.
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE, CANCER_TYPE_DETAILED, ONCOTREE_CODE, SOMATIC_STATUS))
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
### Aqui vamos observar os estados, distribuições e correlações dos nossos dados, incluindo entender o que podemos fazer para normalização dos dados. ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Logaritmização das colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS,
ANEUPLOIDY_SCORE, FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS,
MSI_SENSOR_SCORE, MUTATION_COUNT, TMB_NONSYNONYMOUS, AGE,
BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS),
~ if(all(. >= 0)) log(. + 1) else .))
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# # Tratamento de NAs e transformação de dados categóricos
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
#
# # Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
#                   FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
#                   TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
# Aplicada a logaritmização e min-max scaling aos dados mRNA
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
### Aqui vamos observar os estados, distribuições e correlações dos nossos dados, incluindo entender o que podemos fazer para normalização dos dados. ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Logaritmização das colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS,
MSI_SENSOR_SCORE, MUTATION_COUNT, TMB_NONSYNONYMOUS,
OS_MONTHS, PFS_MONTHS),
~ if(all(. >= 0)) log(. + 1) else .))
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# # Tratamento de NAs e transformação de dados categóricos
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
#
# # Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
#                   FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
#                   TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
# Aplicada a logaritmização e min-max scaling aos dados mRNA
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
### Aqui vamos observar os estados, distribuições e correlações dos nossos dados, incluindo entender o que podemos fazer para normalização dos dados. ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
## Inicialização do API cBioPortal e obtenção dos dados do estudo "blca_msk_tcga_2020"
# Automáticamente define a working directory para o local do ficheiro .Rmd
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
# Inicialização da API do cBioPortal
cbio <- cBioPortal()
# Obter dados clínicos
bladder_clin <- clinicalData(api = cbio, studyId = "blca_msk_tcga_2020")
dim(bladder_clin)  # Deve retornar 476 linhas e 42 colunas
# Carrega os dados do cBioPortal
bladder = cBioDataPack("blca_msk_tcga_2020", ask = FALSE)
# Lista os nomes dos ensaios disponíveis no pacote dos dados do CBioPortal
names(assays(bladder))
names(colData(bladder)) # tipos de metadados associados a cada amostra
# Summary dos dados
summary(bladder)
# Consulta dos dados de mrna e conversão em dataframe.
min_max_scaling <- function(x) {
if(all(is.na(x)) || length(unique(na.omit(x))) == 1) {
return(rep(0, length(x)))  # Retorna zeros se os valores forem NA ou iguais
}
min_val <- min(x, na.rm = TRUE)
max_val <- max(x, na.rm = TRUE)
return((x - min_val) / (max_val - min_val))
}
#sem o min e max scaling nesta parte ocorre erro no mutate que se segue:
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
# Para verificar as classes das colunas do conjunto de dados:
unlist(lapply(bladder_clin, class))
# Para verificar os tipos das colunas do conjunto de dados:
unlist(lapply(bladder_clin, typeof))
# Conversão de colunas que possuem valores numéricos (no entanto não são) para serem numéricas
# Definir as variáveis como numéricas
bladder_clin <- bladder_clin %>%
mutate(
RAGNUM_HYPOXIA_SCORE = as.numeric(RAGNUM_HYPOXIA_SCORE),
WINTER_HYPOXIA_SCORE = as.numeric(WINTER_HYPOXIA_SCORE),
DFS_MONTHS = as.numeric(DFS_MONTHS),
ANEUPLOIDY_SCORE = as.numeric(ANEUPLOIDY_SCORE),
FRACTION_GENOME_ALTERED = as.numeric(FRACTION_GENOME_ALTERED),
MSI_SCORE_MANTIS = as.numeric(MSI_SCORE_MANTIS),
MSI_SENSOR_SCORE = as.numeric(MSI_SENSOR_SCORE),
MUTATION_COUNT = as.numeric(MUTATION_COUNT),
TMB_NONSYNONYMOUS = as.numeric(TMB_NONSYNONYMOUS),
AGE = as.numeric(AGE),
BUFFA_HYPOXIA_SCORE = as.numeric(BUFFA_HYPOXIA_SCORE),
OS_MONTHS = as.numeric(OS_MONTHS),
PFS_MONTHS = as.numeric(PFS_MONTHS),
#SAMPLE_COUNT = as.numeric(SAMPLE_COUNT),
)
# Vamos substituir os NAs das colunas numéricas pela mediana de cada coluna e os NAs das não numéricas por "Unknown". Define-se primeiro as colunas numéricas para conseguirmos correr o nosso código de substituição dos NAs.
# Substituição dos NAs
na_columns <- sapply(bladder_clin, function(x) any(is.na(x)))
for (col_name in names(bladder_clin)) {
if (na_columns[col_name]) {
if (is.numeric(bladder_clin[[col_name]])) {
median_val <- median(bladder_clin[[col_name]], na.rm = TRUE)
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- median_val
} else {
bladder_clin[[col_name]][is.na(bladder_clin[[col_name]])] <- "Unknown"
}
}
}
# Tendo os NAs substituidos, podemos agora definir variáveis como fatores:
# Definir as variáveis como fatores
bladder_clin <- bladder_clin %>%
mutate(
PFS_STATUS = as.factor(PFS_STATUS),
PRIOR_DX = as.factor(PRIOR_DX),
RADIATION_THERAPY = as.factor(RADIATION_THERAPY),
SEX = as.factor(SEX),
DFS_STATUS = as.factor(DFS_STATUS),
sampleId = as.factor(sampleId),
ANALYSIS_COHORT = as.factor(ANALYSIS_COHORT),
#CANCER_TYPE = as.factor(CANCER_TYPE),
#CANCER_TYPE_DETAILED = as.factor(CANCER_TYPE_DETAILED),
DISTANT_METS = as.factor(DISTANT_METS),
GRADE = as.factor(GRADE),
LYMPH_NODE_STATUS = as.factor(LYMPH_NODE_STATUS),
#ONCOTREE_CODE = as.factor(ONCOTREE_CODE),
PRIMARY_VS_SECONDARY = as.factor(PRIMARY_VS_SECONDARY),
PRIOR_INTRAVESICAL_CHEMOTHERAPY = as.factor(PRIOR_INTRAVESICAL_CHEMOTHERAPY),
SAMPLE_TYPE = as.factor(SAMPLE_TYPE),
#SOMATIC_STATUS = as.factor(SOMATIC_STATUS),
TUMOR_STAGE = as.factor(TUMOR_STAGE),
AJCC_PATHOLOGIC_TUMOR_STAGE = as.factor(AJCC_PATHOLOGIC_TUMOR_STAGE),
COHORT = as.factor(COHORT),
ETHNICITY = as.factor(ETHNICITY),
OS_STATUS = as.factor(OS_STATUS),
PATH_M_STAGE = as.factor(PATH_M_STAGE),
PATH_N_STAGE = as.factor(PATH_N_STAGE),
PATH_T_STAGE = as.factor(PATH_T_STAGE),
RACE = as.factor(RACE)
)
# Estudando as colunas, verifica-se que as colunas "SAMPLE_COUNT", "CANCER_TYPE", "CANCER_TYPE_DETAILED", "ONCOTREE_CODE" e "SOMATIC_STATUS" têm sempre 1 único valor cada, logo serão removidas.
bladder_clin <- subset(bladder_clin, select = -c(SAMPLE_COUNT, CANCER_TYPE, CANCER_TYPE_DETAILED, ONCOTREE_CODE, SOMATIC_STATUS))
# Verificar se ainda há valores NA
summary(bladder_clin)
# Para saber se a substituição dos NAs ocorreu, verifica os resultados do "summary(bladder_clin)", se ainda aparecerem "NA's", algo está mal, se não houverem "NA's" nas colunas numéricas e houverem valores "Unknown" nas colunas não numéricas, está tudo certo!
### Se corrermos este código antes de definir as variáveis numéricas, o tratamento dos NA's não ocorre! ###
# Logaritmização das colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS,
FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS,
MSI_SENSOR_SCORE, MUTATION_COUNT, TMB_NONSYNONYMOUS,
OS_MONTHS, PFS_MONTHS),
~ if(all(. >= 0)) log(. + 1) else .))
# Aplicação do Min-Max Scaling (definido anteriormente) às colunas numéricas
bladder_clin <- bladder_clin %>%
mutate(across(where(is.numeric), min_max_scaling))
# # Tratamento de NAs e transformação de dados categóricos
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
#
# # Aplicação do Min-Max Scaling exclusivamente às colunas numéricas
# bladder_clin <- bladder_clin %>%
#   mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>%
#   mutate(across(where(is.character), as.factor)) %>%
#   mutate(across(c(RAGNUM_HYPOXIA_SCORE, WINTER_HYPOXIA_SCORE, DFS_MONTHS, ANEUPLOIDY_SCORE,
#                   FRACTION_GENOME_ALTERED, MSI_SCORE_MANTIS, MSI_SENSOR_SCORE, MUTATION_COUNT,
#                   TMB_NONSYNONYMOUS, AGE, BUFFA_HYPOXIA_SCORE, OS_MONTHS, PFS_MONTHS), as.numeric))
# Aplicada a logaritmização e min-max scaling aos dados mRNA
dados_mrna_df <- as.data.frame(assays(bladder)$mrna_seq_v2_rsem) %>%
mutate(across(where(is.numeric), min_max_scaling))
#######################codigo todo alterado para o novo dataset até aqui#################
### Aqui vamos observar os estados, distribuições e correlações dos nossos dados, incluindo entender o que podemos fazer para normalização dos dados. ###
# Pairplot para ver os gráficos das correlações possíveis entre colunas
# Subconjunto do conjunto de dados para apenas incluir as colunas numéricas
numeric_data <- bladder_clin[, sapply(bladder_clin, is.numeric)]
# Criação de um pairplot com só as colunas numéricas para verificar as correlações
pairplot <- GGally::ggpairs(numeric_data, cardinality_threshold = Inf,
upper = list(continuous = wrap("cor", size = 2, color = "brown")),
lower = list(continuous = wrap("points", size = 0.25, color = "dodgerblue3"))) +
theme(text = element_text(size = 4),
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(size = 4),
panel.spacing = unit(0.1, "lines")) # Ajusta espaços entre os gráficos/painéis
pairplot
ggsave("pairplot_blca.png", pairplot, width = 10, height = 6) # Guarda o pairplot como uma imagem .png no working directory. Os parâmetros "width" e "height" definem o tamanho dele, caso queiram ver o pairplot, ele está disponível na mesma pasta que este ficheiro .Rmd!
